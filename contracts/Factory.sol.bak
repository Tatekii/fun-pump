// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.27;

import {Token} from "./Token.sol";

contract Factory {
    uint256 private constant DECIMALS = 10 ** 18;
    // 众筹到期时，看是否满足最低金额
    uint256 public constant SOFT_CAP = 1 ether; // Minimum funding goal
    uint256 public constant FUNDING_TARGET = 3 ether; // Hard cap
    uint256 public constant FUNDING_LIMIT = 500_000 * DECIMALS;

    uint256 public fee;
    uint256 public platformFee = 50; // 0.5%
    uint256 public constant FEE_DENOMINATOR = 10000;
    address public immutable owner;
    bool public paused;
    bool private _locked;

    uint256 public totalTokens;
    address[] public tokens;
    mapping(address => TokenSale) public tokenForSale;
    mapping(address => mapping(address => uint256)) public contributions; // token => user => amount
    mapping(address => mapping(address => uint256)) public userPurchases; // token => user => purchased amount
    struct TokenSale {
        address token;
        string name;
        address creator;
        uint256 sold;
        uint256 raised;
        uint256 startTime;
        uint256 endTime;
        bool isOpen;
        SaleStage stage;
    }

    enum SaleStage {
        SETUP,
        WHITELIST,
        PUBLIC,
        ENDED
    }

    struct VestingSchedule {
        uint256 cliff; // Time before tokens start vesting
        uint256 duration; // Total vesting duration
        uint256 released; // Amount of tokens released
    }

    mapping(address => mapping(address => VestingSchedule))
        public vestingSchedules;

    event ContractCreated(address indexed creator, address contractAddress);
    event Buy(address indexed buyer, address indexed token, uint256 amount);
    event SaleClosed(address indexed token);
    event FundsDeposited(address indexed token, uint256 amount);
    event TokensDeposited(address indexed token, uint256 amount);
    event FeeUpdated(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract paused");
        _;
    }

    modifier whenPaused() {
        require(paused, "Contract not paused");
        _;
    }

    // 重入保护
    modifier nonReentrant() {
        require(!_locked, "Reentrant call");
        _locked = true;
        _;
        _locked = false;
    }

    constructor(uint256 _fee) {
        fee = _fee;
        owner = msg.sender;
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function setFee(uint256 _newFee) external onlyOwner {
        require(_newFee > 0, "Fee cannot be zero");
        emit FeeUpdated(fee, _newFee);
        fee = _newFee;
    }

    function updatePlatformFee(uint256 _newFee) external onlyOwner {
        require(_newFee <= 1000, "Fee too high"); // Max 10%
        platformFee = _newFee;
    }

    function calculateFees(uint256 _amount) public view returns (uint256) {
        return (_amount * platformFee) / FEE_DENOMINATOR;
    }

    function getTokenForSale(
        uint256 _index
    ) public view returns (TokenSale memory) {
        return tokenForSale[tokens[_index]];
    }

    function getCost(uint256 _sold) public pure returns (uint256 cost) {
        uint256 floor = 0.0001 ether;
        uint256 step = 0.0001 ether;
        uint256 increment = 10000 ether;

        // Increases by 0.0001 ETH for every 10,000 tokens sold

        cost = (step * (_sold / increment)) + floor;
    }

    function create(
        string memory _name,
        string memory _symbol
    ) public payable whenNotPaused {
        require(
            bytes(_name).length > 0 && bytes(_name).length <= 32,
            "Invalid name length"
        );
        require(
            bytes(_symbol).length > 0 && bytes(_symbol).length <= 8,
            "Invalid symbol length"
        );
        require(msg.value >= fee, "Insufficient fee");

        Token token = new Token(msg.sender, _name, _symbol, 1_000_000 ether);

        tokens.push(address(token));

        totalTokens++;

        TokenSale memory _sale = TokenSale(
            address(token),
            _name,
            msg.sender,
            0,
            0,
            0,
            0,
            true,
            SaleStage.SETUP
        );

        tokenForSale[address(token)] = _sale;

        emit ContractCreated(msg.sender, address(token));
    }

    function buy(
        address _token,
        uint256 _amount
    ) external payable nonReentrant whenNotPaused {
        TokenSale storage curForSale = tokenForSale[_token];

        require(curForSale.isOpen == true, "Buying closed");
        require(_amount >= 1 ether, "Amount too low");
        require(_amount <= 10000 ether, "Amount exceeded");

        uint256 cost = getCost(curForSale.sold);
        uint256 price = cost * (_amount / 10 ** 18);

        // Add payment validation
        require(msg.value >= price, "Insufficient payment");

        // 退还多余金额
        if (msg.value > price) {
            (bool success, ) = payable(msg.sender).call{
                value: msg.value - price
            }("");
            require(success, "Refund failed");
        }

        uint256 totalPurchased = userPurchases[_token][msg.sender] + _amount;
        require(totalPurchased <= FUNDING_LIMIT, "Exceeds allocation");

        userPurchases[_token][msg.sender] = totalPurchased;

        // 已出售金额
        curForSale.sold += _amount;

        //
        curForSale.raised += price;

        contributions[_token][msg.sender] += msg.value;

        // 命中众筹目标
        // 总额达到3ETH或者发行500000个token
        if (
            curForSale.sold >= FUNDING_LIMIT ||
            curForSale.raised >= FUNDING_TARGET
        ) {
            // 关闭购买
            curForSale.isOpen = false;

            emit SaleClosed(_token);
        }

        // transfer token from contract to buyer
        Token(_token).transfer(msg.sender, _amount);

        emit Buy(msg.sender, _token, _amount);
    }

    function deposit(address _token) external nonReentrant {
        Token token = Token(_token);
        TokenSale memory curForSale = tokenForSale[_token];

        require(curForSale.isOpen == false, "Token funding not reached");

        // Transfers all tokens held by this contract to the creator of the token sale.
        uint256 tokenAmount = token.balanceOf(address(this));
        token.transfer(curForSale.creator, tokenAmount);

        // Transfers all ETH raised during the sale to the creator
        uint256 ethAmount = curForSale.raised;
        (bool success, ) = payable(curForSale.creator).call{value: ethAmount}(
            ""
        );

        require(success, "ETH transfer failed");

        emit FundsDeposited(_token, ethAmount);
        emit TokensDeposited(_token, tokenAmount);
    }

    function withdraw(uint256 _amount) external onlyOwner {
        (bool success, ) = payable(owner).call{value: _amount}("");
        require(success, "ETH withdraw failed");
    }

    function checkFundingStatus(address _token) public view returns (bool) {
        TokenSale storage sale = tokenForSale[_token];
        return sale.raised >= SOFT_CAP;
    }

    // 众筹失败 退款
    function claimRefund(address _token) external nonReentrant {
        TokenSale storage sale = tokenForSale[_token];
        require(block.timestamp > sale.endTime, "Sale not ended");
        require(sale.raised < SOFT_CAP, "Softcap reached");

        uint256 amount = contributions[_token][msg.sender];
        require(amount > 0, "No contribution");

        contributions[_token][msg.sender] = 0;
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Refund failed");
    }

    // TODO PENDING
    // function configureVesting(
    //     address _token,
    //     uint256 _cliff,
    //     uint256 _duration
    // ) external {
    //     require(msg.sender == tokenForSale[_token].creator, "Not creator");
    //     // Set vesting schedule
    // }

    // TODO PENDING
    // function emergencyWithdraw(address _token) external onlyOwner whenPaused {
    //     TokenSale storage sale = tokenForSale[_token];
    //     require(sale.isOpen, "Sale not active");

    //     // Return funds to contributors
    //     // Transfer remaining tokens back to creator
    // }

    function setStage(address _token, SaleStage _stage) external {
        require(msg.sender == tokenForSale[_token].creator, "Not creator");
        tokenForSale[_token].stage = _stage;
    }
}
